# 面向对象的原则

1. 隔离变化
2. 各司其职
3. 语言层面：封装代码/数据
4. 规格层面：可被使用的一系列接口
5. 概念层面：拥有某种责任的实体

## 不要把设计模式当成算法学习

## 设计模式8大原则

1. DIP（依赖倒置原则）：高层模块（稳定）不应依赖于底层模块（变化），二者都应该依赖于抽象。ch1中，mainForm从依赖于Line、Rect、Circle转变为二者都依赖于Shape抽象类——隔离变化、贯穿所有。
2. OCP（开放封闭原则）：对扩展开放，对修改封闭。类模块应该是可扩展的（增加新的类），但是不可修改。ch1中，只需要增加一个Circle.h即可完成对代码的调整，即扩展。
3. SRP（单一职责原则）：强调一个类应该只有一个原因引起变化，也就是说，一个类应该只有一个职责。如果一个类的职责有多个，那么将来对某个职责的更改可能会影响到其他职责，导致类的复杂性增加。SRP有如下优点：
   1. 降低耦合：当一个类承担多个职责时，类之间的依赖性会增加，耦合度变高。SRP 有助于降低类之间的耦合，使系统更易于维护。
   2. 提高可读性：每个类职责明确，代码结构更加清晰，便于其他开发者理解和使用。
   3. 简化测试：每个类只需测试其单一的功能，测试用例变得简单且高效
   4. 违反SRP的例子，Report的3个功能中任意的修改，都会导致整个类修改，以至于需要重新测试
   ```cpp
    class Report {
    public:
        void generateReport() {
            // 生成报告
        }
        
        void saveToFile() {
            // 保存报告到文件
        }

        void sendEmail() {
            // 发送报告邮件
        }
    };

   ```
   5. 符合SRP的例子，每个功能清晰隔离
   ```cpp
    class Report {
    public:
        void generateReport() {
            // 生成报告
        }
    };

    class ReportSaver {
    public:
        void saveToFile(Report& report) {
            // 保存报告到文件
        }
    };

    class EmailSender {
    public:
        void sendEmail(Report& report) {
            // 发送报告邮件
        }
    };

   ```
4. LSP（Liskov替换原则）：子类必须能够替换他们的基类（IS-A），用继承来表达类型的抽象
   1. 子类如果不适用父类的方法，那么说明不适合使用继承，父类的方法应当要适用于子类
   ```cpp
   参考ch1中shape类，被Line、Rect、Circle继承
   ```
5. 接口隔离原则（ISP）
   1. 不应强迫客户程序依赖他们不用的方法
   2. 接口应该小而完备（如果太多public方法，会导致不必要的依赖）
6. 优先使用对象组合，而不是类继承
   1. 类继承为白箱复用，一定程度上破坏了类的封装性，子类与父类耦合程度高
   2. 组合为黑箱复用，只要求具有定义良好的接口即可
7. 封装变化点
   1. 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行更改，而不会对另一侧产生不良的影响，从而实现松耦合
8. 针对接口编程，而不是针对实现编程
   1. 不讲变量类型声明为某个特定的具体类，而是声明为某个接口
   2. 客户程序无需获知对象的具体类型，只需要知道具备什么接口
   3. 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”

## 产业强盛的标志，接口标准化
    秦朝统一六国

## 设计模式的灵活性
    毕升的活字印刷术

## 将设计原则提升为设计经验
1. Design Idioms
   1. 描述与特定编程语言相关的低层模式，技巧惯用法
2. Design Patterns
   1. 描述类与相互通信对象之间的组织关系，包括它们的角色、职责、协作方式等方面
3. Architectural Patterns
   1. 描述系统中与基本结构组织相关的高层模式，包括子系统划分、职责、以及如何组织他们关系的规则